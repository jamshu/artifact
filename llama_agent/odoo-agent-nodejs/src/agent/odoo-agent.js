import path from 'path';
import chalk from 'chalk';
import { LLMManager } from '../llm/llm-manager.js';
import { ToonParser } from '../parsers/toon-parser.js';
import { FileChange } from './file-change.js';
import { FileManager } from '../utils/file-manager.js';
import { UIHelpers } from '../utils/ui-helpers.js';
import {
  getModuleCreationPrompt,
  getModuleCustomizationPrompt,
  getDebugIssuePrompt,
  getCodeAnalysisPrompt
} from '../prompts/templates.js';
import config from '../config/config.js';

/**
 * OdooAgent - Main AI agent for Odoo development
 */
export class OdooAgent {
  constructor(llmProvider = null) {
    this.llmManager = new LLMManager(llmProvider);
    this.config = config;
  }

  /**
   * Create a new Odoo module
   * @param {string} moduleName - Name of the module
   * @param {string} description - Module description
   * @param {string} features - Required features
   * @returns {Promise<object>} Result with success status and module path
   */
  async createModule(moduleName, description, features) {
    try {
      UIHelpers.showInfo(`Creating Odoo module: ${moduleName}`);

      const spinner = UIHelpers.showSpinner('Generating module structure with AI...');

      // Generate prompt
      const prompt = getModuleCreationPrompt(
        moduleName,
        description,
        features,
        this.config.odoo.version
      );

      // Get LLM response
      const response = await this.llmManager.invoke(prompt);

      spinner.stop();

      console.log(chalk.gray('\nðŸ“¥ Received response from AI\n'));

      // Parse response
      let moduleData;
      try {
        moduleData = ToonParser.parseModuleCreation(response);
      } catch (parseError) {
        UIHelpers.showError(`Failed to parse AI response: ${parseError.message}`);
        console.log(chalk.gray('\nRaw response:\n'));
        console.log(response.slice(0, 500) + '...');
        throw parseError;
      }

      // Validate module data
      if (!moduleData.files || moduleData.files.length === 0) {
        throw new Error('No files generated by AI');
      }

      UIHelpers.showSuccess(`Generated ${moduleData.files.length} files`);

      // Create FileChange objects
      const modulePath = path.join(this.config.odoo.addonsPath, moduleName);
      const changes = FileChange.fromParsedArray(moduleData.files, modulePath);

      // Show changes and get approval
      const approved = config.agent.autoApprove || await UIHelpers.askForApproval(changes);

      if (!approved) {
        return {
          success: false,
          message: 'Operation cancelled by user'
        };
      }

      // Apply changes
      console.log(chalk.cyan('\nâš™ Applying changes...\n'));
      const results = await FileManager.applyFileChanges(changes);

      // Show results
      UIHelpers.showResults(results);

      if (results.successful > 0) {
        return {
          success: true,
          modulePath,
          results
        };
      } else {
        return {
          success: false,
          message: 'Failed to create module files',
          results
        };
      }
    } catch (error) {
      UIHelpers.showError(`Module creation failed: ${error.message}`);
      console.error(error);
      return {
        success: false,
        error: error.message
      };
    }
  }

  /**
   * Customize an existing Odoo module
   * @param {string} modulePath - Path to the module
   * @param {string} customizationRequest - Description of customization
   * @returns {Promise<object>} Result with success status
   */
  async customizeModule(modulePath, customizationRequest) {
    try {
      UIHelpers.showInfo(`Customizing module at: ${modulePath}`);

      // Check if module exists
      const moduleStructure = await FileManager.getModuleStructure(modulePath);

      if (!moduleStructure.exists) {
        throw new Error(`Module not found at: ${modulePath}`);
      }

      // Read key files
      const manifestPath = path.join(modulePath, '__manifest__.py');
      const manifestContent = await FileManager.readFile(manifestPath) || 'Not found';

      // Get existing structure description
      const existingStructure = `
Directories: ${moduleStructure.directories.join(', ')}
Files: ${moduleStructure.files.join(', ')}
`;

      const fileContents = `
__manifest__.py:
${manifestContent}
`;

      const spinner = UIHelpers.showSpinner('Analyzing module and generating customizations...');

      // Generate prompt
      const prompt = getModuleCustomizationPrompt(
        modulePath,
        customizationRequest,
        existingStructure,
        fileContents,
        this.config.odoo.version
      );

      // Get LLM response
      const response = await this.llmManager.invoke(prompt);

      spinner.stop();

      console.log(chalk.gray('\nðŸ“¥ Received customization plan from AI\n'));

      // Parse response
      let customizationData;
      try {
        customizationData = ToonParser.parseModuleCustomization(response);
      } catch (parseError) {
        UIHelpers.showError(`Failed to parse AI response: ${parseError.message}`);
        throw parseError;
      }

      // Show analysis
      if (customizationData.analysis) {
        console.log(chalk.bold.cyan('\nðŸ“‹ Analysis:\n'));
        console.log(chalk.white(JSON.stringify(customizationData.analysis, null, 2)));
        console.log();
      }

      if (!customizationData.files || customizationData.files.length === 0) {
        throw new Error('No file changes generated by AI');
      }

      UIHelpers.showSuccess(`Generated ${customizationData.files.length} file change(s)`);

      // Create FileChange objects
      const changes = [];
      for (const fileData of customizationData.files) {
        const fullPath = path.join(modulePath, fileData.path);
        const originalContent = await FileManager.readFile(fullPath) || '';

        const change = new FileChange(
          fullPath,
          fileData.action || 'modify',
          originalContent,
          fileData.content,
          fileData.description
        );

        changes.push(change);
      }

      // Show changes and get approval
      const approved = config.agent.autoApprove || await UIHelpers.askForApproval(changes);

      if (!approved) {
        return {
          success: false,
          message: 'Operation cancelled by user'
        };
      }

      // Apply changes
      console.log(chalk.cyan('\nâš™ Applying customizations...\n'));
      const results = await FileManager.applyFileChanges(changes);

      // Show results
      UIHelpers.showResults(results);

      return {
        success: results.successful > 0,
        results
      };
    } catch (error) {
      UIHelpers.showError(`Module customization failed: ${error.message}`);
      console.error(error);
      return {
        success: false,
        error: error.message
      };
    }
  }

  /**
   * Debug an Odoo issue
   * @param {string} errorMessage - Error message
   * @param {string} codeContext - Code context (optional)
   * @param {string} modulePath - Module path (optional)
   * @returns {Promise<object>} Debug results with fixes
   */
  async debugIssue(errorMessage, codeContext = '', modulePath = '') {
    try {
      UIHelpers.showInfo('Analyzing Odoo issue...');

      const spinner = UIHelpers.showSpinner('Getting diagnosis from AI...');

      // Generate prompt
      const prompt = getDebugIssuePrompt(
        errorMessage,
        codeContext,
        modulePath,
        this.config.odoo.version
      );

      // Get LLM response
      const response = await this.llmManager.invoke(prompt);

      spinner.stop();

      console.log(chalk.gray('\nðŸ“¥ Received diagnosis from AI\n'));

      // Parse response
      let debugData;
      try {
        debugData = ToonParser.parseDebugIssue(response);
      } catch (parseError) {
        UIHelpers.showError(`Failed to parse AI response: ${parseError.message}`);
        throw parseError;
      }

      // Show debug information
      UIHelpers.showDebugInfo(debugData);

      // If there are fixes, offer to apply them
      if (debugData.fixes && debugData.fixes.length > 0) {
        console.log(chalk.bold.green(`\nðŸ”§ ${debugData.fixes.length} fix(es) available\n`));

        const applyFixes = await UIHelpers.askConfirm('Would you like to apply these fixes?', true);

        if (applyFixes) {
          // Create FileChange objects
          const changes = [];
          for (const fix of debugData.fixes) {
            const filePath = modulePath ? path.join(modulePath, fix.file_path) : fix.file_path;
            const originalContent = await FileManager.readFile(filePath) || '';

            const change = new FileChange(
              filePath,
              fix.action || 'modify',
              originalContent,
              fix.content,
              fix.explanation
            );

            changes.push(change);
          }

          // Show changes and get approval
          const approved = config.agent.autoApprove || await UIHelpers.askForApproval(changes);

          if (approved) {
            console.log(chalk.cyan('\nâš™ Applying fixes...\n'));
            const results = await FileManager.applyFileChanges(changes);
            UIHelpers.showResults(results);

            return {
              success: results.successful > 0,
              debugData,
              results
            };
          }
        }
      }

      return {
        success: true,
        debugData,
        message: 'Diagnosis completed (no fixes applied)'
      };
    } catch (error) {
      UIHelpers.showError(`Debug operation failed: ${error.message}`);
      console.error(error);
      return {
        success: false,
        error: error.message
      };
    }
  }

  /**
   * Analyze code quality
   * @param {string} filePath - Path to file to analyze
   * @returns {Promise<object>} Analysis results
   */
  async analyzeCode(filePath) {
    try {
      UIHelpers.showInfo(`Analyzing code: ${filePath}`);

      // Read file
      const code = await FileManager.readFile(filePath);

      if (!code) {
        throw new Error(`Cannot read file: ${filePath}`);
      }

      const spinner = UIHelpers.showSpinner('Analyzing code quality...');

      // Generate prompt
      const prompt = getCodeAnalysisPrompt(filePath, code, this.config.odoo.version);

      // Get LLM response
      const response = await this.llmManager.invoke(prompt);

      spinner.stop();

      console.log(chalk.gray('\nðŸ“¥ Received analysis from AI\n'));

      // Parse response
      let analysisData;
      try {
        analysisData = ToonParser.parseCodeAnalysis(response);
      } catch (parseError) {
        UIHelpers.showError(`Failed to parse AI response: ${parseError.message}`);
        throw parseError;
      }

      // Display analysis
      console.log(chalk.bold.cyan('\nðŸ“Š Code Analysis Results:\n'));

      if (analysisData.summary) {
        console.log(chalk.bold('Summary:'));
        console.log(`  Quality: ${analysisData.summary.overall_quality}`);
        console.log(`  Issues: ${analysisData.summary.main_issues}`);
        console.log(`  Recommendation: ${analysisData.summary.recommendation}`);
        console.log();
      }

      if (analysisData.issues && analysisData.issues.length > 0) {
        console.log(chalk.bold.red(`\nâš  Issues Found (${analysisData.issues.length}):\n`));
        analysisData.issues.forEach((issue, idx) => {
          const severity = issue.severity === 'high' ? chalk.red(issue.severity.toUpperCase())
            : issue.severity === 'medium' ? chalk.yellow(issue.severity.toUpperCase())
            : chalk.blue(issue.severity.toUpperCase());

          console.log(`${idx + 1}. [${severity}] ${issue.description}`);
          console.log(`   Line: ${issue.line} | Category: ${issue.category}`);
          console.log(`   Suggestion: ${issue.suggestion}`);
          console.log();
        });
      }

      if (analysisData.security_concerns && analysisData.security_concerns.length > 0) {
        console.log(chalk.bold.red(`\nðŸ”’ Security Concerns (${analysisData.security_concerns.length}):\n`));
        analysisData.security_concerns.forEach((concern, idx) => {
          console.log(`${idx + 1}. [${chalk.red(concern.risk_level)}] ${concern.concern}`);
          console.log(`   Mitigation: ${concern.mitigation}`);
          console.log();
        });
      }

      return {
        success: true,
        analysisData
      };
    } catch (error) {
      UIHelpers.showError(`Code analysis failed: ${error.message}`);
      console.error(error);
      return {
        success: false,
        error: error.message
      };
    }
  }

  /**
   * Get current LLM provider name
   * @returns {string}
   */
  getProviderName() {
    return this.llmManager.getProviderName();
  }

  /**
   * Switch LLM provider
   * @param {string} provider - New provider name
   */
  switchProvider(provider) {
    this.llmManager.switchProvider(provider);
    UIHelpers.showSuccess(`Switched to ${provider} provider`);
  }
}

export default OdooAgent;
