from collections import defaultdict
from odoo import models, fields, _
from odoo.tools import groupby
from odoo.tools.float_utils import float_is_zero
from odoo.exceptions import UserError, ValidationError


class PickingInvoiceWizard(models.TransientModel):
    _name = 'picking.invoice.wizard'
    _description = 'Picking Invoice Wizard'

    order_ids = fields.Many2many('purchase.order', string='Purchase Order')
    stock_picking_ids = fields.Many2many('stock.picking', string='Stock Pickings', domain="[('purchase_id', 'in', order_ids), ('grn_invoice_ids', '=', False), ('state', '=', 'done')]")

    def create_account_move(self):
        """Create the invoice associated to the PO."""
        precision = self.env['decimal.precision'].precision_get('Product Unit of Measure')

        if not self.stock_picking_ids:
            raise ValidationError(_('Please select a shipment before creating the bill'))

        # 1) Prepare invoice vals and clean-up the section lines
        invoice_vals_list = []
        sequence = 10

        product_dict = defaultdict(lambda: 0)
        purchase_line_list = []
        for picking_id in self.stock_picking_ids:
            for move_line in picking_id.move_line_ids:
                if move_line.location_dest_usage == 'internal' and move_line.location_usage != 'internal':
                    purchase_line = move_line.move_id.purchase_line_id
                    product_dict[purchase_line.id] += move_line.product_uom_id._compute_quantity(move_line.qty_done, purchase_line.product_uom)
                else:
                    raise UserError(_('Please create the credit note for returns.'))
                purchase_line_list.append(purchase_line.id)

        purchase_line_list = list(set(purchase_line_list))

        for order in self.order_ids.filtered(lambda order: order.bill_creation_source in ['receipts','initial']):
            if order.invoice_status != 'to invoice':
                continue

            order = order.with_company(order.company_id)
            pending_section = None
            # Invoice values.
            invoice_vals = order._prepare_invoice()
            # Invoice line values (keep only necessary sections).
            for line in order.order_line.filtered(lambda line: line.id in purchase_line_list):
                move_line_qty = product_dict.get(line.id, 0.0)
                if line.display_type == 'line_section':
                    pending_section = line
                    continue
                if not float_is_zero(line.qty_to_invoice, precision_digits=precision):
                    if pending_section:
                        line_vals = pending_section._prepare_account_move_line()
                        line_vals.update({'sequence': sequence})
                        invoice_vals['invoice_line_ids'].append((0, 0, line_vals))
                        sequence += 1
                        pending_section = None
                    line_vals = line._prepare_account_move_line()
                    line_vals.update({'sequence': sequence, 'quantity': move_line_qty})
                    invoice_vals['invoice_line_ids'].append((0, 0, line_vals))
                    sequence += 1
            invoice_vals_list.append(invoice_vals)

        if not invoice_vals_list:
            raise UserError(_('There is no invoiceable line. If a product has a control policy based on received quantity, please make sure that a quantity has been received.'))

        # 2) group by (company_id, partner_id, currency_id, invoice_origin) for batch creation
        new_invoice_vals_list = []
        for grouping_keys, invoices in groupby(invoice_vals_list, key=lambda x: (x.get('company_id'), x.get('partner_id'), x.get('currency_id'))):
            origins = set()
            payment_refs = set()
            refs = set()
            ref_invoice_vals = None
            for invoice_vals in invoices:
                if not ref_invoice_vals:
                    ref_invoice_vals = invoice_vals
                else:
                    ref_invoice_vals['invoice_line_ids'] += invoice_vals['invoice_line_ids']
                origins.add(invoice_vals['invoice_origin'])
                payment_refs.add(invoice_vals['payment_reference'])
                refs.add(invoice_vals['ref'])
            ref_invoice_vals.update({
                'ref': ', '.join(refs)[:2000],
                'invoice_origin': ', '.join(origins),
                'payment_reference': len(payment_refs) == 1 and payment_refs.pop() or False,
            })
            new_invoice_vals_list.append(ref_invoice_vals)
        invoice_vals_list = new_invoice_vals_list

        # 3) Create invoices.
        moves = self.env['account.move']
        AccountMove = self.env['account.move'].with_context(default_move_type='in_invoice')
        for vals in invoice_vals_list:
            if not vals.get('invoice_line_ids',False):
                continue
            vals["grn_picking_ids"] = [(6, 0, self.stock_picking_ids.ids)]
            moves |= AccountMove.with_company(vals['company_id']).create(vals)

        # 4) Some moves might actually be refunds: convert them if the total amount is negative
        # We do this after the moves have been created since we need taxes, etc. to know if the total
        # is actually negative or not
        moves.filtered(lambda m: m.currency_id.round(m.amount_total) < 0).action_switch_invoice_into_refund_credit_note()
        self.order_ids.write({'bill_creation_source': 'receipts'})
        return self.order_ids.action_view_invoice(moves)